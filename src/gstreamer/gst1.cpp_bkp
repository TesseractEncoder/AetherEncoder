/*
gst-launch-1.0 videotestsrc ! video/x-raw,width=1920,height=1080,format=NV12,framerate=60000/1001 ! videoconvert ! video/x-raw,width=1920,height=1080,format=NV12 ! 
queue leaky=downstream max-size-buffers=3 ! interpipesink name=camsrc caps=video/x-raw,format=NV12 sync=true async=false

gst-launch-1.0 decklinkvideosrc device-number=0 connection=sdi mode=1080p5994 buffer-size=5 ! "video/x-raw,format=UYVY" ! videoconvert ! "video/x-raw,format=NV12" ! 
nvh264enc  zerolatency=true strict-gop=false gop-size=60 bframes=0  nonref-p=false  rc-lookahead=0 qp-const=0 rc-mode=2 preset=4 vbv-buffer-size=1024 bitrate=8000 max-bitrate=8000 ! 
"video/x-h264,profile=(string)main" ! h264parse config-interval=1 ! mpegtsmux alignment=7 name=mux decklinkaudiosrc device-number=0 channels=2 buffer-size=5 ! "audio/x-raw,format=S16LE" ! 
audioconvert ! voaacenc bitrate=128000 ! aacparse ! mux. mux. ! tee name=t ! queue ! srtsink streamid=1 uri=srt://104.189.184.146:23002 wait-for-connection=false  sync=true
*/

#include "../AetherEncoder.h"
#include "gst.h"

static gboolean bus_call (GstBus *bus, GstMessage *msg, gpointer data);

int gstEncodeElement::createEncodePipe(AetherAction AA)
{
    //createMulticastPipe MP;
    /* Initialisation */
    loop = g_main_loop_new (NULL, FALSE);
    
    /* Create souce*/
    src = gst_element_factory_make ("videotestsrc", "decklinksrc");
    //g_object_set (G_OBJECT (src), "device-number", 0, "mode", 15,NULL);
    capsfiltersrc = gst_element_factory_make("capsfilter", NULL);
    //srccaps = gst_caps_from_string("video/x-raw,format=UYVY");
    srccaps = gst_caps_from_string("video/x-raw,width=1920,height=1080,format=NV12,framerate=60000/1001");
    g_object_set (capsfiltersrc, "caps",srccaps, NULL);
    gst_caps_unref (srccaps); 

    /* Create videorate*/
   /* vrate = gst_element_factory_make ("videorate", "videorate");
    capsfilterRate = gst_element_factory_make("capsfilter", NULL);
    capsRate = gst_caps_from_string ("video/x-raw,framerate=60/1");
    g_object_set ( capsfilterRate, "caps", capsRate, NULL);
    gst_caps_unref(capsRate);*/

    /*Create videoconvert*/
    vconv  = gst_element_factory_make ("videoconvert","videoconv");
    capsfilterConvert = gst_element_factory_make("capsfilter", NULL);
    capsConvert = gst_caps_from_string ("video/x-raw,format=NV12");
    g_object_set (capsfilterConvert, "caps", capsConvert, NULL);
    gst_caps_unref(capsConvert);
    
    /* Create nvh264enc */
    H264Encode  = gst_element_factory_make ("nvh264enc","nvEnc");
    g_object_set (G_OBJECT (H264Encode), "strict-gop", 0, "gop-size", 60, "bframes", 0, "nonref-p", 0, "rc-lookahead", 0, "qp-const",0, "rc-mode", 2 , "preset", 4, "vbv-buffer-size", 1024, "bitrate", 8000, "max-bitrate", 8000, NULL);
    capsfilterH264enc = gst_element_factory_make("capsfilter", NULL);
    capsH264enc = gst_caps_from_string ("video/x-h264,profile=(string)main");
    g_object_set (capsfilterH264enc, "caps", capsH264enc, NULL);
    gst_caps_unref(capsH264enc);

    /* Create h264parse */
    H264Parse = gst_element_factory_make ("h264parse","H264parse");
    g_object_set (G_OBJECT (H264Parse), "config-interval", -1, NULL);
    //mux     = gst_element_factory_make ("mpegtsmux","mux");

    /* Create queue */
    queue = gst_element_factory_make ("queue","que");

    /*Create sink*/
    sink = gst_element_factory_make ("interpipesink", "camsrc");
   // g_object_set (G_OBJECT (sink), "name", "camsrc", NULL);

    //sink = gst_element_factory_make ("udpsink", "sink");
   // g_object_set (G_OBJECT (sink), "host", "227.1.1.1", "port", 26000, NULL);
    
    P = gst_pipeline_new ("AetherEncoder");

    if (!P || !src || !vconv || !H264Encode || !H264Parse || !queue || !sink) 
	{
		g_printerr ("One element could not be created. Exiting.\n");
		return -1;
	}
    bus = gst_pipeline_get_bus (GST_PIPELINE (P));
    bus_watch_id = gst_bus_add_watch (bus, bus_call, loop);
    gst_object_unref (bus);

    /* we add all elements into the pipeline */
    gst_bin_add_many (GST_BIN (P),
                        src,capsfiltersrc,vconv,capsfilterConvert,H264Encode,capsfilterH264enc,H264Parse,queue,sink, NULL);

    /* we link the elements together */
    gst_element_link_many (src,capsfiltersrc,vconv,capsfilterConvert,H264Encode,capsfilterH264enc,H264Parse,queue,sink, NULL);
   // g_signal_connect (tes_videoConv, "pad-added", G_CALLBACK (on_pad_added), tes_encoder);

    

    /* Set the pipeline to "playing" state*/
    g_print ("Now playing: \n");
    gst_element_set_state (P, GST_STATE_PLAYING);

    //createMulticastPipe MP(AA);
    P1 = gst_parse_launch("interpipesrc listen-to=camsrc is-live=true allow-renegotiation=true stream-sync=restart-ts ! mpegtsmux alignment=7 ! udpsink host=227.1.1.1 port=26000", &error);
    //g_printerr ("Error: %s\n", error->message);
    //g_error_free (error);

    loop1 = g_main_loop_new (NULL, FALSE);
    bus1 = gst_element_get_bus (P1);
    gst_bus_add_signal_watch (bus1);
    gst_object_unref (bus1);
    gst_element_set_state (P1, GST_STATE_PLAYING);
    g_main_loop_run (loop1);
    gst_element_set_state (P1, GST_STATE_NULL);
    gst_object_unref (P1);
    /* Iterate */
    g_print ("Running...\n");
   g_main_loop_run (loop1);


    /* Out of the main loop, clean up nicely */
  /*  g_print ("Returned, stopping playback\n");
    gst_element_set_state (P, GST_STATE_NULL);

    g_print ("Deleting pipeline\n");
    gst_object_unref (GST_OBJECT (P));
    g_source_remove (bus_watch_id);
    g_main_loop_unref (loop);*/

    return 0;
}

static gboolean bus_call (GstBus *bus, GstMessage *msg, gpointer data)
{
    GMainLoop *loop = (GMainLoop *) data;

    switch (GST_MESSAGE_TYPE (msg)) {

        case GST_MESSAGE_EOS:
            g_print ("End of stream\n");
            g_main_loop_quit (loop);
            break;

        case GST_MESSAGE_ERROR: {
            gchar  *debug;
            GError *error;

            gst_message_parse_error (msg, &error, &debug);
            g_free (debug);

            g_printerr ("Error: %s\n", error->message);
            g_error_free (error);

            g_main_loop_quit (loop);
            break;
        }
        default:
            break;
    }

    return TRUE;
}

createMulticastPipe::createMulticastPipe(AetherAction AA)
{
    cout << "call constructor" << endl;

    P1 = gst_parse_launch("interpipesrc listen-to=camsrc is-live=true allow-renegotiation=true stream-sync=restart-ts ! udpsink host=227.1.1.1 port=26000", &error);
    //g_printerr ("Error: %s\n", error->message);
    //g_error_free (error);

    loop1 = g_main_loop_new (NULL, FALSE);
    bus1 = gst_element_get_bus (P1);
    gst_bus_add_signal_watch (bus1);
    gst_object_unref (bus1);
    gst_element_set_state (P1, GST_STATE_PLAYING);
    g_main_loop_run (loop1);
    gst_element_set_state (P1, GST_STATE_NULL);
    gst_object_unref (P1);
}
